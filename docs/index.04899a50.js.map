{"mappings":"A,S,E,C,E,O,G,E,U,C,E,O,C,C,C,I,E,C,EGAA,EAAe,wd,I,E,C,ECAf,EAAe,6WFKf,MAAM,EAAU,CAAC,EGLF,0kBHKS,EAAA,GAAU,EAAA,GAAM,CAGxC,IAAI,EAAc,KAAK,KAAK,CAAC,KAAK,MAAM,GAAK,EAAQ,MAAM,EAG3D,MAAM,EAAW,IAAI,aAAa,CAAC,GAAI,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,EAAG,GAAI,EAAG,EAAE,EAItE,EAAS,SAAS,cAAc,CAAC,UACjC,EAAK,EAAO,UAAU,CAAC,QAC7B,CAAA,EAAO,KAAK,CAHO,IAInB,EAAO,MAAM,CAJM,IAOnB,EAAG,QAAQ,CAAC,EAAG,EAAG,EAAO,KAAK,CAAE,EAAO,MAAM,EAC7C,EAAG,UAAU,CAAC,EAAG,EAAG,EAAG,GACvB,EAAG,KAAK,CAAC,EAAG,gBAAgB,EAG5B,MAAM,EAAS,CAAC;;;;;;AAMhB,CAAC,CAED,SAAS,EAAc,CAAc,EAEnC,IAAM,EAAK,EAAG,YAAY,CAAC,EAAG,aAAa,CAC1B,CAAA,CAAO,CAAC,EAAY,CACrC,EAAG,YAAY,CAAC,EAAI,GACpB,EAAG,aAAa,CAAC,GAGjB,IAAM,EAAK,EAAG,YAAY,CAAC,EAAG,eAAe,EAC7C,EAAG,YAAY,CAAC,EAAI,GACpB,EAAG,aAAa,CAAC,GAEjB,IAAM,EAAU,EAAG,aAAa,GAChC,EAAG,YAAY,CAAC,EAAS,GACzB,EAAG,YAAY,CAAC,EAAS,GACzB,EAAG,WAAW,CAAC,GAGf,IAAM,EAAU,EAAG,YAAY,GAyB/B,OAxBA,EAAG,UAAU,CAAC,EAAG,YAAY,CAAE,GAC/B,EAAG,UAAU,CAAC,EAAG,YAAY,CAAE,EAAU,EAAG,WAAW,EAGvD,EAAG,UAAU,CAAC,GAGT,EAAG,kBAAkB,CAAC,EAAI,EAAG,cAAc,GAAG,QAAQ,GAAG,CAAC,EAAG,gBAAgB,CAAC,IAC9E,EAAG,kBAAkB,CAAC,EAAI,EAAG,cAAc,GAAG,QAAQ,GAAG,CAAC,EAAG,gBAAgB,CAAC,IAC9E,EAAG,mBAAmB,CAAC,EAAS,EAAG,WAAW,GAAG,QAAQ,GAAG,CAAC,EAAG,iBAAiB,CAAC,IAGvF,EAAQ,KAAK,CAAG,EAAG,kBAAkB,CAAC,EAAS,SAC/C,EAAG,SAAS,CAAC,EAAQ,KAAK,CAAE,GAG5B,EAAQ,KAAK,CAAG,EAAG,kBAAkB,CAAC,EAAS,SAC/C,EAAG,SAAS,CAAC,EAAQ,KAAK,CAxDT,KA2DjB,EAAQ,eAAe,CAAG,EAAG,iBAAiB,CAAC,EAAS,mBACxD,EAAG,uBAAuB,CAAC,EAAQ,eAAe,EAClD,EAAG,mBAAmB,CAAC,EAAQ,eAAe,CAAE,EAAG,EAAG,KAAK,CAAE,CAAA,EAAO,EAAG,GAEhE,CACT,CAEA,IAAI,EAAU,EAAc,CAAO,CAAC,EAAY,EAE5C,EAAO,EACX,MAAM,EAAO,KACX,IACA,EAAG,SAAS,CAAC,EAAQ,KAAK,CAAE,GAC5B,EAAG,UAAU,CAAC,EAAG,SAAS,CAAE,EAAG,GAC/B,WAAW,EAAM,GACnB,EACA,IAEA,EAAO,OAAO,CAAG,KACf,EAAe,AAAA,CAAA,EAAc,CAAA,EAAK,EAAQ,MAAM,CAChD,EAAU,EAAc,CAAO,CAAC,EAAY,CAC9C","sources":["<anon>","src/main.js","src/webgl.js","src/redWaves.glsl","src/waves.glsl","src/funky.glsl"],"sourcesContent":["\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\nvar $0f15715cbfbe7ebf$exports = {};\n$0f15715cbfbe7ebf$exports = \"precision highp float;\\n#define GLSLIFY 1\\n\\nuniform float uTime;\\nuniform float uSize;\\n\\nvoid main() {\\n  float x = gl_FragCoord.x;\\n  float y = gl_FragCoord.y;\\n  float nx = x / uSize + 0.5;\\n  float ny = y / uSize + 0.5;\\n\\n  // float time = uTime;\\n  float st = uTime / 5.0;\\n\\n//\\n  float c = sin(((ny * ny - sin(st * 0.1)) * (nx / ny - 0.3 * cos(st * 0.05)) * 2.95 + st * 0.2) * 80.0);\\n\\n  gl_FragColor = vec4(c * 0.5, 0.0, c * (1.0 + sin(st)) * 0.2, 1.0);\\n}\\n\";\n\n\nvar $dc658b87bc6d7097$exports = {};\n$dc658b87bc6d7097$exports = \"precision highp float;\\n#define GLSLIFY 1\\n\\nuniform float uTime;\\n\\nvoid main() {\\n  float x = gl_FragCoord.x;\\n  float y = gl_FragCoord.y;\\n  float time = uTime;\\n  float tek = mod((y / 2.0 + sin((x) / 6.0)) + cos(y / 20.0) * 3.0 + cos(x / 20.0 + time / 20.0) * 1.4 - time / 2.0, 35.0) / 15.0;\\n  gl_FragColor = vec4(tek * 0.4, 0.1, 2.0 - tek * 0.5, 1.0);\\n}\\n\";\n\n\nvar $2873a52efb3d4c73$exports = {};\n$2873a52efb3d4c73$exports = \"precision highp float;\\n#define GLSLIFY 1\\n\\nuniform float uTime;\\nuniform float uSize;\\n\\nvoid main() {\\n  vec2 pos = gl_FragCoord.xy / uSize;\\n  float x = pos.x;\\n  float y = pos.y;\\n  float t = uTime / 15.0;\\n\\n  float faq = uSize / 3.5;\\n\\n  float circles1 = sin(sin(t + 0.0) * 1.0 + x * faq) + cos(cos(t + 0.0) * 1.0 + y * faq);\\n  float circles2 = sin(sin(t + 3.1) * 4.0 + x * faq) + cos(cos(t + 3.14) * 4.0 + y * faq);\\n  float circles3 = sin(sin(t + 0.0) * 4.0 + x * faq) + cos(cos(t + 0.0) * 4.0 + y * faq);\\n\\n  gl_FragColor = vec4(circles1, circles2, circles3, 1.0);\\n}\\n\";\n\n\n// List of all the fragment shaders\nconst $a07aa2f7429f37c8$var$shaders = [\n    (0, (/*@__PURE__*/$parcel$interopDefault($2873a52efb3d4c73$exports))),\n    (0, (/*@__PURE__*/$parcel$interopDefault($0f15715cbfbe7ebf$exports))),\n    (0, (/*@__PURE__*/$parcel$interopDefault($dc658b87bc6d7097$exports)))\n];\n// Pick a random shader\nlet $a07aa2f7429f37c8$var$shaderIndex = Math.floor(Math.random() * $a07aa2f7429f37c8$var$shaders.length);\n// Just a fullscreen square\nconst $a07aa2f7429f37c8$var$vertices = new Float32Array([\n    -1,\n    -1,\n    1,\n    1,\n    -1,\n    1,\n    -1,\n    -1,\n    1,\n    -1,\n    1,\n    1\n]);\n// Setup canvas\nconst $a07aa2f7429f37c8$var$canvasSize = 256;\nconst $a07aa2f7429f37c8$var$canvas = document.getElementById(\"canvas\");\nconst $a07aa2f7429f37c8$var$gl = $a07aa2f7429f37c8$var$canvas.getContext(\"webgl\");\n$a07aa2f7429f37c8$var$canvas.width = $a07aa2f7429f37c8$var$canvasSize;\n$a07aa2f7429f37c8$var$canvas.height = $a07aa2f7429f37c8$var$canvasSize;\n// Reset view\n$a07aa2f7429f37c8$var$gl.viewport(0, 0, $a07aa2f7429f37c8$var$canvas.width, $a07aa2f7429f37c8$var$canvas.height);\n$a07aa2f7429f37c8$var$gl.clearColor(0, 0, 0, 1);\n$a07aa2f7429f37c8$var$gl.clear($a07aa2f7429f37c8$var$gl.COLOR_BUFFER_BIT);\n// Simple vertex shader for the 2d square that will be fullscreen\nconst $a07aa2f7429f37c8$var$vertex = `\nattribute vec2 aVertexPosition;\n\nvoid main() {\ngl_Position = vec4(aVertexPosition, 0.0, 1.0);\n}\n`;\nfunction $a07aa2f7429f37c8$var$createProgram(fragmentShader) {\n    // Vertex shader stuff\n    const vs = $a07aa2f7429f37c8$var$gl.createShader($a07aa2f7429f37c8$var$gl.VERTEX_SHADER);\n    const fragment = $a07aa2f7429f37c8$var$shaders[$a07aa2f7429f37c8$var$shaderIndex];\n    $a07aa2f7429f37c8$var$gl.shaderSource(vs, $a07aa2f7429f37c8$var$vertex);\n    $a07aa2f7429f37c8$var$gl.compileShader(vs);\n    // Fragment shader stuff\n    const fs = $a07aa2f7429f37c8$var$gl.createShader($a07aa2f7429f37c8$var$gl.FRAGMENT_SHADER);\n    $a07aa2f7429f37c8$var$gl.shaderSource(fs, fragmentShader);\n    $a07aa2f7429f37c8$var$gl.compileShader(fs);\n    const program = $a07aa2f7429f37c8$var$gl.createProgram();\n    $a07aa2f7429f37c8$var$gl.attachShader(program, vs);\n    $a07aa2f7429f37c8$var$gl.attachShader(program, fs);\n    $a07aa2f7429f37c8$var$gl.linkProgram(program);\n    // Pass our glorious square into a buffer\n    const vbuffer = $a07aa2f7429f37c8$var$gl.createBuffer();\n    $a07aa2f7429f37c8$var$gl.bindBuffer($a07aa2f7429f37c8$var$gl.ARRAY_BUFFER, vbuffer);\n    $a07aa2f7429f37c8$var$gl.bufferData($a07aa2f7429f37c8$var$gl.ARRAY_BUFFER, $a07aa2f7429f37c8$var$vertices, $a07aa2f7429f37c8$var$gl.STATIC_DRAW);\n    // Load the programm\n    $a07aa2f7429f37c8$var$gl.useProgram(program);\n    // Show errors if any\n    if (!$a07aa2f7429f37c8$var$gl.getShaderParameter(vs, $a07aa2f7429f37c8$var$gl.COMPILE_STATUS)) console.log($a07aa2f7429f37c8$var$gl.getShaderInfoLog(vs));\n    if (!$a07aa2f7429f37c8$var$gl.getShaderParameter(fs, $a07aa2f7429f37c8$var$gl.COMPILE_STATUS)) console.log($a07aa2f7429f37c8$var$gl.getShaderInfoLog(fs));\n    if (!$a07aa2f7429f37c8$var$gl.getProgramParameter(program, $a07aa2f7429f37c8$var$gl.LINK_STATUS)) console.log($a07aa2f7429f37c8$var$gl.getProgramInfoLog(program));\n    // Init time uniform\n    program.uTime = $a07aa2f7429f37c8$var$gl.getUniformLocation(program, \"uTime\");\n    $a07aa2f7429f37c8$var$gl.uniform1f(program.uTime, 1.0);\n    // size uniform \n    program.uSize = $a07aa2f7429f37c8$var$gl.getUniformLocation(program, \"uSize\");\n    $a07aa2f7429f37c8$var$gl.uniform1f(program.uSize, $a07aa2f7429f37c8$var$canvasSize);\n    // eh?\n    program.aVertexPosition = $a07aa2f7429f37c8$var$gl.getAttribLocation(program, \"aVertexPosition\");\n    $a07aa2f7429f37c8$var$gl.enableVertexAttribArray(program.aVertexPosition);\n    $a07aa2f7429f37c8$var$gl.vertexAttribPointer(program.aVertexPosition, 2, $a07aa2f7429f37c8$var$gl.FLOAT, false, 0, 0);\n    return program;\n}\nlet $a07aa2f7429f37c8$var$program = $a07aa2f7429f37c8$var$createProgram($a07aa2f7429f37c8$var$shaders[$a07aa2f7429f37c8$var$shaderIndex]);\nlet $a07aa2f7429f37c8$var$time = 0;\nconst $a07aa2f7429f37c8$var$loop = ()=>{\n    $a07aa2f7429f37c8$var$time++;\n    $a07aa2f7429f37c8$var$gl.uniform1f($a07aa2f7429f37c8$var$program.uTime, $a07aa2f7429f37c8$var$time);\n    $a07aa2f7429f37c8$var$gl.drawArrays($a07aa2f7429f37c8$var$gl.TRIANGLES, 0, 6);\n    setTimeout($a07aa2f7429f37c8$var$loop, 50);\n};\n$a07aa2f7429f37c8$var$loop();\n$a07aa2f7429f37c8$var$canvas.onclick = ()=>{\n    $a07aa2f7429f37c8$var$shaderIndex = ($a07aa2f7429f37c8$var$shaderIndex + 1) % $a07aa2f7429f37c8$var$shaders.length;\n    $a07aa2f7429f37c8$var$program = $a07aa2f7429f37c8$var$createProgram($a07aa2f7429f37c8$var$shaders[$a07aa2f7429f37c8$var$shaderIndex]);\n};\n\n\n\n\n\n\n//# sourceMappingURL=index.04899a50.js.map\n","import \"./webgl\";\nimport \"./style.css\";\nimport '@fontsource-variable/eb-garamond';\n","import redWaves from \"./redWaves.glsl\";\nimport waves from \"./waves.glsl\";\nimport funky from \"./funky.glsl\";\n\n// List of all the fragment shaders\nconst shaders = [funky, redWaves, waves];\n\n// Pick a random shader\nlet shaderIndex = Math.floor(Math.random() * shaders.length);\n\n// Just a fullscreen square\nconst vertices = new Float32Array([-1, -1, 1, 1, -1, 1, -1, -1, 1, -1, 1, 1]);\n\n// Setup canvas\nconst canvasSize = 256;\nconst canvas = document.getElementById(\"canvas\");\nconst gl = canvas.getContext(\"webgl\");\ncanvas.width = canvasSize;\ncanvas.height = canvasSize;\n\n// Reset view\ngl.viewport(0, 0, canvas.width, canvas.height);\ngl.clearColor(0, 0, 0, 1);\ngl.clear(gl.COLOR_BUFFER_BIT);\n\n// Simple vertex shader for the 2d square that will be fullscreen\nconst vertex = `\nattribute vec2 aVertexPosition;\n\nvoid main() {\ngl_Position = vec4(aVertexPosition, 0.0, 1.0);\n}\n`;\n\nfunction createProgram(fragmentShader) {\n  // Vertex shader stuff\n  const vs = gl.createShader(gl.VERTEX_SHADER);\n  const fragment = shaders[shaderIndex];\n  gl.shaderSource(vs, vertex);\n  gl.compileShader(vs);\n\n  // Fragment shader stuff\n  const fs = gl.createShader(gl.FRAGMENT_SHADER);\n  gl.shaderSource(fs, fragmentShader);\n  gl.compileShader(fs);\n\n  const program = gl.createProgram();\n  gl.attachShader(program, vs);\n  gl.attachShader(program, fs);\n  gl.linkProgram(program);\n\n  // Pass our glorious square into a buffer\n  const vbuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, vbuffer);\n  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\n\n  // Load the programm\n  gl.useProgram(program);\n\n  // Show errors if any\n  if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) console.log(gl.getShaderInfoLog(vs));\n  if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) console.log(gl.getShaderInfoLog(fs));\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) console.log(gl.getProgramInfoLog(program));\n\n  // Init time uniform\n  program.uTime = gl.getUniformLocation(program, \"uTime\");\n  gl.uniform1f(program.uTime, 1.0);\n\n  // size uniform \n  program.uSize = gl.getUniformLocation(program, \"uSize\");\n  gl.uniform1f(program.uSize, canvasSize);\n\n  // eh?\n  program.aVertexPosition = gl.getAttribLocation(program, \"aVertexPosition\");\n  gl.enableVertexAttribArray(program.aVertexPosition);\n  gl.vertexAttribPointer(program.aVertexPosition, 2, gl.FLOAT, false, 0, 0);\n\n  return program\n}\n\nlet program = createProgram(shaders[shaderIndex])\n\nlet time = 0;\nconst loop = () => {\n  time++;\n  gl.uniform1f(program.uTime, time);\n  gl.drawArrays(gl.TRIANGLES, 0, 6);\n  setTimeout(loop, 50);\n};\nloop();\n\ncanvas.onclick = () => {\n  shaderIndex = (shaderIndex + 1) % shaders.length;\n  program = createProgram(shaders[shaderIndex])\n}\n","precision highp float;\n\nuniform float uTime;\nuniform float uSize;\n\nvoid main() {\n  float x = gl_FragCoord.x;\n  float y = gl_FragCoord.y;\n  float nx = x / uSize + 0.5;\n  float ny = y / uSize + 0.5;\n\n  // float time = uTime;\n  float st = uTime / 5.0;\n\n//\n  float c = sin(((ny * ny - sin(st * 0.1)) * (nx / ny - 0.3 * cos(st * 0.05)) * 2.95 + st * 0.2) * 80.0);\n\n  gl_FragColor = vec4(c * 0.5, 0.0, c * (1.0 + sin(st)) * 0.2, 1.0);\n}\n","precision highp float;\n\nuniform float uTime;\n\nvoid main() {\n  float x = gl_FragCoord.x;\n  float y = gl_FragCoord.y;\n  float time = uTime;\n  float tek = mod((y / 2.0 + sin((x) / 6.0)) + cos(y / 20.0) * 3.0 + cos(x / 20.0 + time / 20.0) * 1.4 - time / 2.0, 35.0) / 15.0;\n  gl_FragColor = vec4(tek * 0.4, 0.1, 2.0 - tek * 0.5, 1.0);\n}\n","precision highp float;\n\nuniform float uTime;\nuniform float uSize;\n\nvoid main() {\n  vec2 pos = gl_FragCoord.xy / uSize;\n  float x = pos.x;\n  float y = pos.y;\n  float t = uTime / 15.0;\n\n  float faq = uSize / 3.5;\n\n  float circles1 = sin(sin(t + 0.0) * 1.0 + x * faq) + cos(cos(t + 0.0) * 1.0 + y * faq);\n  float circles2 = sin(sin(t + 3.1) * 4.0 + x * faq) + cos(cos(t + 3.14) * 4.0 + y * faq);\n  float circles3 = sin(sin(t + 0.0) * 4.0 + x * faq) + cos(cos(t + 0.0) * 4.0 + y * faq);\n\n  gl_FragColor = vec4(circles1, circles2, circles3, 1.0);\n}\n"],"names":["$parcel$interopDefault","a","__esModule","default","$0f15715cbfbe7ebf$exports","$dc658b87bc6d7097$exports","$a07aa2f7429f37c8$var$shaders","$a07aa2f7429f37c8$var$shaderIndex","Math","floor","random","length","$a07aa2f7429f37c8$var$vertices","Float32Array","$a07aa2f7429f37c8$var$canvas","document","getElementById","$a07aa2f7429f37c8$var$gl","getContext","width","height","viewport","clearColor","clear","COLOR_BUFFER_BIT","$a07aa2f7429f37c8$var$vertex","$a07aa2f7429f37c8$var$createProgram","fragmentShader","vs","createShader","VERTEX_SHADER","shaderSource","compileShader","fs","FRAGMENT_SHADER","program","createProgram","attachShader","linkProgram","vbuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","useProgram","getShaderParameter","COMPILE_STATUS","console","log","getShaderInfoLog","getProgramParameter","LINK_STATUS","getProgramInfoLog","uTime","getUniformLocation","uniform1f","uSize","aVertexPosition","getAttribLocation","enableVertexAttribArray","vertexAttribPointer","FLOAT","$a07aa2f7429f37c8$var$program","$a07aa2f7429f37c8$var$time","$a07aa2f7429f37c8$var$loop","drawArrays","TRIANGLES","setTimeout","onclick"],"version":3,"file":"index.04899a50.js.map"}